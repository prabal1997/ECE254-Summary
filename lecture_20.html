<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lecture_20</title></head><body><h2><span style="font-weight: bold;">Dynamic Memory Allocation Interface</span></h2><span style="font-weight: bold;"></span>Our generalized interface has two functions:<br><span style="font-family: Courier New,Courier,monospace;">void* allocate_memory(int size)</span>;<br style="font-family: Courier New,Courier,monospace;"><span style="font-family: Courier New,Courier,monospace;">void deallocate_memory(void* mem_block);<br></span><h2><span style="font-weight: bold;">Dynamic Memory Allocation Implementation</span></h2><ul><li><span style="font-weight: bold;">Doubly Linked-Lists:&nbsp;</span></li><ul><li><span style="font-weight: bold;">Fixed Block Sizes: </span>Linked-list holds a list of pointers to fixed-size memory locations.</li><ul><li><span style="font-weight: bold;">Allocation:</span> Remove<span style="font-weight: bold;"> </span>the required number of nodes, return memory addresses in NULL-terminated array.</li><li><span style="font-weight: bold;">Deallocation: </span>Add a new node storing the address of de-allocated location to linked-list. </li></ul><li><span style="font-weight: bold;">Variable Block Sizes:&nbsp;</span><span style="font-style: italic;">Each&nbsp;</span>node represents a <span style="font-style: italic;">memory location</span>, <span style="font-style: italic;">size</span>, <span style="font-style: italic;">allocation status</span>.</li><ul><li><span style="font-weight: bold;">Allocation: </span>Find a node of appropriate size, or split an existing unallocated node.</li><li><span style="font-weight: bold;">Deallocation: </span>Find the allocated node in linked-list; set status to <span style="font-style: italic;">unallocated.</span></li></ul></ul><li><span style="font-weight: bold;">Bitmaps:&nbsp;</span>Bit-array keeping track whether each memory block is allocated.<span style="font-weight: bold;"></span></li></ul><h2><span style="font-weight: bold;">Dynamic Memory Allocation Terms</span></h2><ul><li><span style="font-weight: bold;">External Fragmentation: </span>Number of non-coalesced chunks of un-allocated memory.</li><li><span style="font-weight: bold;">Internal Fragmentation:&nbsp;</span>Unused memory in an allocated block.</li><li><span style="font-weight: bold;">Coalesce:&nbsp;</span>Combining adjacent un-allocated blocks; <span style="font-style: italic;">reduces&nbsp;</span><span style="font-weight: bold;">External Fragementation</span></li><li><span style="font-weight: bold;">Compaction: </span>Re-positioning allocated memory together to&nbsp;<span style="font-style: italic;">reduce </span><span style="font-weight: bold;">External Fragmentation</span></li></ul><h2><span style="font-weight: bold;">Dynamic Memory Allocation</span> <span style="font-weight: bold;">Strategies</span></h2><span style="font-weight: bold;">Fixed Block Sizes: </span>suitable for embedded systems, where speed is neccessary.<span style="font-weight: bold;"><br></span><ul><li><span style="font-weight: bold;">One Size Option:&nbsp;</span>Memory blocks are constant size; multiple (possibly non-contiguous) blocks returned on large allocation request.</li><li><span style="font-weight: bold;">Varying Size Options: &nbsp;</span>Fixed-sized memory blocks of different sizes (<span style="font-style: italic;">generally</span> powers of 2)</li></ul><span style="font-weight: bold;">Variable Block Sizes: </span><span style="font-weight: bold;"></span>suitable for general purpose systems.<br>&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;"><br>&nbsp;&nbsp; &nbsp;&nbsp; NOTE:</span> let allocation request be for <span style="font-style: italic;">n </span>blocks<ul><li><span style="font-weight: bold;">First Fit </span><span style="font-style: italic;">(Fastest, Best Performance)</span><span style="font-weight: bold;">:&nbsp;</span>Find first chunk with <span style="font-style: italic;">n </span>unallocated blocks.&nbsp;</li><li><span style="font-weight: bold;">Next Fit: </span>essentially <span style="font-weight: bold;">First Fit</span>, except search for next allocation starts where previous halted.</li><li><span style="font-weight: bold;">Best Fit:&nbsp;</span>Find smallest chunk with atleast&nbsp;<span style="font-style: italic;">n&nbsp;</span>blocks.</li><li><span style="font-weight: bold;">Worst Fit:&nbsp;</span>Find largest chunks with atleast&nbsp;<span style="font-style: italic;">n&nbsp;</span>blocks.</li><li><span style="font-weight: bold;">Quick Fit: </span>An optimization involving having chunks for commonly used memory allocation requests prepared.</li><li><span style="font-weight: bold;">Binary Buddy:</span></li><ul><li> <span style="font-weight: bold;">Allocation: </span>Look for the smallest chunk that has&nbsp;<span style="font-style: italic;">n&nbsp;</span>blocks. If&nbsp;<span style="font-style: italic;">n&nbsp;</span> &lt;= <span style="font-style: italic;">chunk</span> <span style="font-style: italic;">size/2,&nbsp;</span>then keep splitting the chunk into smaller, and smaller halves.</li><li><span style="font-weight: bold;">Deallocation: </span>After de-allocation, attempt merging chunks of <span style="font-style: italic;">identical </span>sizes.<span style="font-weight: bold;"> </span></li></ul></ul><span style="font-weight: bold;"></span></body></html>