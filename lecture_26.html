<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lecture_26</title></head><body><h2>Uniprocessor Scheduling Algorithms</h2><ul><li><span style="font-weight: bold;">Relevent Data:&nbsp;</span>scheduler keeps tracks of the following values regarding processes.</li><ul><li><span style="font-weight: bold;"><span style="font-weight: bold;">Waiting Time</span></span>: mean/median time process waits for a resource, or in scheduler.</li><li><span style="font-weight: bold;"><span style="font-weight: bold;">Running Time</span></span>: time a process was permitted to run by scheduler.</li><ul><li>not<span style="font-weight: bold;"><span style="font-weight: bold;"> </span></span><span style="font-style: italic;">neccesarily</span> the CPU usage time.</li></ul><li><span style="font-weight: bold;"><span style="font-weight: bold;">Turnaround Time: </span></span>wall-clock duration of process execution.</li></ul><li><span style="font-weight: bold;">Uniprocessor Scheudling Algorithms</span>:<span style="font-weight: bold;"></span></li><ul><li><span style="font-weight: bold;">Highest-priority:</span></li><ul><li><span style="font-weight: bold;"></span>Just a priority queue.</li><li>Very-low priority process may starve</li><ul><li>Happens if every new process has a <span style="font-style: italic;">higer priority</span> than the very-low priority tasks </li></ul></ul><li><span style="font-weight: bold;">First-code, First-serve:</span></li><ul><li>FIFO Queue</li><li>Everyone gets chance to run - no starvation</li><li><span style="font-style: italic;">Average Turnaround Time&nbsp;</span>wildly varies</li><ul><li>Messes with <span style="font-style: italic;">scheduler statistics</span>, and <span style="font-style: italic;">users</span>.</li></ul><li>No interrupting on <span style="font-style: italic;">CPU-bound</span> processes</li><li><span style="font-style: italic;">I/O-bound</span> processes halt system excessively </li></ul><li><span style="font-weight: bold;">Round-robin:</span></li><ul><li>FIFO Queue with Time-slicing</li><ul><li><span style="font-weight: bold;">Time-slicing: </span>an interrupt generated after <span style="font-style: italic;">t </span>clock cycles as a prompt to scheduler</li><li>Track average time <span style="font-style: italic;">r </span>after which process requests a resource</li><li>Assing time-slice length <span style="font-style: italic;">t </span>slightly longer than <span style="font-style: italic;">r.</span></li></ul><li><span style="font-style: italic;">I/O-bound</span> process spent <span style="font-style: italic;">multiple</span> time-slices just waiting<span style="font-style: italic;">.<br></span></li><li><span style="font-weight: bold;">Virtual Round Robin: </span>Prevents I/O bound process' disadvantage.<span style="font-weight: bold;"> </span>Maintains <span style="font-style: italic;">main-queue</span>, <span style="font-style: italic;">auxiliary-queue</span></li><ul><li>Processes from <span style="font-style: italic;">main-queue</span> are executed.</li><li>A process requesting resource is sent to corresponding queue</li><li>Process continues with <span style="font-style: italic;">higher </span>priority after resource arrival</li><ul><li>Runs for <span style="font-style: italic;">t</span>-<span style="font-style: italic;">r </span>time.</li></ul></ul></ul><li><span style="font-weight: bold;">Shortest Process Next:</span></li><ul><li>Predict <span style="font-style: italic;">turn-around</span> times, priority-queue by shortest <span style="font-style: italic;">turn-around</span> times.</li><li>Reduces total <span style="font-style: italic;">turn-around</span> times, improves <span style="font-style: italic;">responsiveness</span> </li></ul><li><span style="font-weight: bold;">Shortest Job Next:</span></li><ul><li>Predict <span style="font-style: italic;">CPU</span><span style="font-weight: bold; font-style: italic;">-</span><span style="font-style: italic;">burst</span> lengths,<span style="font-weight: bold;">&nbsp;</span>priority-queue by smallest <span style="font-style: italic;">CPU-burst</span> length.</li><li>Prediction Methods:</li><ul style="font-weight: bold;"><li>Average:</li><ul style="font-weight: normal;"><li>calculate expected burst-length as:.</li></ul><li>Exponential Average:</li><ul><li><span style="font-weight: normal;">calculate the expected <span style="font-style: italic;">burst-length </span>as</span><span style="font-weight: normal;">.</span></li></ul><ul><li><span style="font-weight: normal; font-style: italic;" class="fontstyle0">&#945;</span><span style="font-weight: normal; font-style: italic;"> 
</span><span style="font-weight: normal;">is a <span style="font-style: italic;">constant</span> b/w 0 and 1.</span></li></ul></ul><li><span style="font-weight: normal;">New processes get an inital <span style="font-style: italic;">prediction </span>score of 0, making them run immediately after current-burst.</span></li><li><span style="font-weight: normal;">Long-process might starve. <br></span></li></ul><li><span style="font-weight: bold;">Smallest Remaining Time:</span></li><ul><li>Modification of<span style="font-weight: bold;"> </span><span style="font-style: italic;">Shortest-Job Next</span><span style="font-weight: bold;"></span></li><li><span style="font-style: italic;">New</span>, or <span style="font-style: italic;">unblocked </span>processes can interrupt current-burst, or be priortized appropriately.<br></li></ul></ul></ul></body></html>