<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lecture_23</title></head>
<body><h1><span style="font-weight: bold;">Virtual Memory I</span></h1><span style="font-weight: bold;">Virtual Memory:<br></span><ul><li>Pretending
that entire process is in main-memory, even though only a subset of
process' pages are in the main-memory at any given time.</li><li> Loading only some of all the pages a process has into main-memory to conserve space, and maximize multi-threaded work.</li></ul><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold;">Thrashing:<br></span><ul><li>When the process/computer spends majority of time only swapping memory pages in and out of memory.</li><li>This is a feature of I/O limited processes.</li></ul><span style="font-weight: bold;">Main Memory as a Cache: </span>Concept of<span style="font-weight: bold;"> </span>Virtual Memory treats main-memory as a cache for <span style="font-style: italic;">pages</span>. <br><br><span style="font-weight: bold;">Memory Reference Process<span style="font-weight: bold;"><span style="font-weight: bold;"><br></span></span></span><ul><li>Check if the memory-address is valid or not.</li><ul><li>If invalid, terminate the program</li></ul><ul><li>If valid:</li></ul><ul><ul><li>If <span style="font-style: italic;">page</span> is in main-memory, continue instruction execution</li></ul></ul><ul><ul><li>If <span style="font-style: italic;">page</span> not in main-memory (<span style="font-style: italic;">Page fault</span>), free the main-memory for a new <span style="font-style: italic;">page</span> using a cache-eviction technique</li></ul></ul><li>If cache-eviction had to be done, write back to disk any changes</li><li>Request a disk-read to load the requested <span style="font-style: italic;">page</span> into the main-memory</li><li>When disk-read complete, update the <span style="font-style: italic;">page table</span></li><li>Restart instruction execution with the requested <span style="font-style: italic;">page</span> in memory</li></ul><div style="margin-left: 40px;"><span style="font-weight: bold;">NOTE:</span><br></div><ul style="margin-left: 40px;"><li>request for memory will cause the process to get blocked if <span style="font-style: italic;">page </span>wasn't in cache.</li><li>Processor will do something useful while the process gets the requested <span style="font-style: italic;">page</span> from hard-disk</li></ul><span style="font-weight: bold;">Instruction Repetion:<br></span><ul><li>Attempting to execute an instruction might lead to multiple <span style="font-style: italic;">page faults.</span></li><li>Neccessary to be able to repeat an instruction that caused the <span style="font-style: italic;">page fault.</span></li><ul><li><span style="font-style: italic;">e.g.</span>: consider <span style="font-family: Courier New,Courier,monospace;">ADD C, B, A</span>, and assume that the <span style="font-family: Courier New,Courier,monospace;">ADD</span> instruction, variable A, B, and C are all in different <span style="font-style: italic;">pages</span>.</li></ul></ul><ul style="margin-left: 80px;"><li>First <span style="font-style: italic;">page fault</span> happens when accessing the instruction.</li><li>Second <span style="font-style: italic;">page fault</span> happens when accessing variable B. Instruction repeats. B does not cause a page fault the second time.</li><li>Third <span style="font-style: italic;">page fault</span> happens when accessing variable A. Instruction repeats.A does not cause a page fault the second time.</li><li>Fourth <span style="font-style: italic;">page fault</span> happens when accessing variable C. Instruction repeats. C does not cause a page fault the second time.</li></ul><span style="font-weight: bold;">Virtual Memory Performance<br></span><ul><li><span style="font-weight: bold;">Cache Hierarchy:</span></li><ul><li>Main Cache behaves like a typical processor-based cache.</li><li>Main-memory behaves like a cache for <span style="font-style: italic;">pages.</span></li><li>Hard-disk plays the role of the slower memory-storage.</li></ul><li><span style="font-weight: bold;">Effective Access Time:</span></li></ul><span style="font-weight: bold;">Copy-on-Write<br></span><ul><li>Process spawning requires <span style="font-style: italic;">cloning</span> the parent to create a child process.</li><li>Quite often, the child process will use <span style="font-family: Courier New,Courier,monospace;">exec()</span> and change its memory contents.</li><ul><li>Possibly quite slow since some of processes' pages will cause <span style="font-style: italic;">page faults.</span></li><li>This leads to make copying the entire parent-process seem resources wastage.</li></ul><li>UNIX lets the child and the parent process <span style="font-style: italic;">share </span>the same <span style="font-style: italic;">pages</span> until either one of the processes' attempts to modify its memory contents</li><li>Only the modifed pages will now be actually copied.<span style="font-weight: bold;"> <br></span></li></ul><span style="font-weight: bold;"><span style="font-weight: bold;"><span style="font-style: italic;"> </span></span></span></body></html>