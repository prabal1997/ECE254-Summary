<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lecture_30</title></head><body><h2><span style="font-weight: bold;">I/O Devices and Drivers</span></h2>For I/O devices, two components are:<br><ul><li><span style="font-weight: bold;">Bus:&nbsp;</span>signals for data transfer and communication</li><li><span style="font-weight: bold;">Controller:&nbsp;</span>electronics operate on hardware ports, bus, devices etc.</li></ul><span style="font-weight: bold;">Device Drivers:</span><br><ul><li><span style="font-weight: bold;"> </span>Software that <span style="font-style: italic;">plugs </span>into OS interface, tells OS about relevant hardware</li><li>Required to <span style="font-style: italic;">translate</span> OS commands to device commands via controller.</li><li><span style="font-weight: bold;">Windows Support:</span></li><ul><li>Allows drivers to run in <span style="font-style: italic;">Kernel Mode</span></li></ul><li style="font-weight: bold;">UNIX Support:</li><ul><li>Able to run <span style="font-style: italic;">some </span>drivers in <span style="font-style: italic;">User Mode.<span style="font-weight: bold;"></span></span></li></ul></ul><span style="font-weight: bold;">Subsystem:<br></span><ul><li>A <span style="font-style: italic;">Driver </span>is connected to the OS via an <span style="font-style: italic;">interface </span>called a sub-system.</li><li><span style="font-style: italic;">Sub-system</span> will translate OS commands to <span style="font-style: italic;">generalized</span> commands</li><li><span style="font-style: italic;">Driver</span> converts commands to device instructions.</li></ul><span style="font-weight: bold;">Device Variations:<br></span><ul><li>Devices can vary in multitude of ways.</li><ul><li><span style="font-weight: bold;">Data Transfer Mode:</span> Devices operate on different data-sizes. <span style="font-style: italic;">e.g. </span>keyboard vs. Hard-disk</li><li><span style="font-weight: bold;">Access Method:</span> Devices may provide Sequential, or Random Access</li><li><span style="font-weight: bold;">Transfer Schedule:</span> Devices may communicate, transfer data <span style="font-style: italic;">Synchronosuly</span>, or <span style="font-style: italic;">Asynchronously</span></li><li><span style="font-weight: bold;">Dedication:</span> Devices may be concurrently shareable, or <span style="font-style: italic;">Dedicated </span>(<span style="font-style: italic;">i.e. </span>no concurrent use).</li><li><span style="font-weight: bold;">Device Speed:</span> Device speeds vary according to device requirements.</li></ul><li>Devices need loose categarization, and then issued only the appropirate commands</li><ul><li><span style="font-style: italic;">e.g. </span>reading a hard-disk charcter-by-character is stupid</li></ul></ul><span style="font-weight: bold;">Data Transfer Mode:<br></span><ul><li><span style="font-weight: bold;">Block Interface:</span></li><ul><li>used for devices such as hard-disks, CDs</li><li>Must support <span style="font-style: italic;">read, write </span>commands; <span style="font-style: italic;">seek </span>commands too if <span style="font-style: italic;">Random-Access.</span></li></ul><li><span style="font-weight: bold;">Character Interface:</span></li><ul><li>used for devices like keyboards, printers etc. that require <span style="font-style: italic;">sequential data-transfer</span>.</li><li>Useful for devices erratically producing small amounts of data <span style="font-style: italic;">e.g.</span> keyboards</li><li>Must support <span style="font-style: italic;">get, put </span>commands<span style="font-style: italic;">.</span></li></ul></ul><span style="font-weight: bold;">Bufferring:<br></span><ul><li>Area of memory storing data to be transferred.</li><li>Good way to deal with speed mismatch b/w producer and consumer.</li><li><span style="font-weight: bold;">Double Buffering:</span></li><ul><li>Data arriving while buffer writes to another device needs to be handled</li><li>Two buffers are used:</li><ul><li>One for storing incoming data, and another for transferring old data.</li><ul><li><span style="font-style: italic;">e.g. </span>A keyboard might have two buffers; while one is emptied, second buffer records the keystrokes.</li></ul><li>Excellent way to handle speed mismatch between producer/consumer</li></ul></ul><li><span style="font-weight: bold;">Spool:&nbsp;</span>Buffer-like system where all incoming requests are stored for devices that can only serve one job at a time.</li></ul><span style="font-weight: bold;">Network Devices:<br></span><ul><li>Network communication tends to be serial</li><li>Block read commnds <span style="font-style: italic;">read</span>, <span style="font-style: italic;">write</span>, <span style="font-style: italic;">seek</span> not appropriate</li><li><span style="font-style: italic;">Sockets </span>model used to communicate b/w client-server:</li><ul><li>Server opens a <span style="font-style: italic;">socket</span></li><li><span style="font-style: italic;"><span style="font-style: italic;">&nbsp;</span></span>A client can <span style="font-style: italic;">plugin </span>to a socket<span style="font-style: italic;"><span style="font-style: italic;"></span>&nbsp;</span></li><li><span style="font-style: italic;">Packets </span>of data transferred b/w client and server</li></ul><li>Server uses <span style="font-style: italic;">select </span>command to manage a set of clients</li><ul><li>Displays what <span style="font-style: italic;">sockets </span>are waiting to send or receive packets.</li></ul></ul><span style="font-weight: bold;">I/O Protection</span>:<br><ul><li>All user acesses to I/O <span style="font-style: italic;">mediated</span> through OS (since they invoke <span style="font-style: italic;">system calls</span>) to confirm validity.</li><ul><li><span style="font-style: italic;">e.g.</span> when a user tries to cancel someone's request on the printer</li></ul><li>Extra checking implemented at cost of overhead</li><li>Special circumstances (<span style="font-style: italic;">e.g. </span>high-performance applications and GPUs) might require waiving this condition to improve performance </li></ul><span style="font-weight: bold;">Kernel I/O Data Structures:<br></span><ul><li>In Linux, everything is a file</li><li>Kernel has a <span style="font-style: italic;">global open-file table</span> <span style="font-style: italic;">i.e. </span>table of any resources under use.</li><ul><li>Each resource file has pointers to is important functions. <span style="font-style: italic;">e.g. seek, read, write</span></li></ul><li>Each process records which <span style="font-style: italic;">files </span>or <span style="font-style: italic;">resources </span>it has 'opened'</li><ul><li>...and holds pointer to <span style="font-style: italic;">files </span>in the <span style="font-style: italic;">global open-file table.</span></li></ul></ul><span style="font-weight: bold;">I/O Scheduling:</span><br><ul><li>Kernel maintains a global structure of I/O&nbsp;requests.</li><li>Kernel re-arranges requests to improve efficiency</li><li>Priority <span style="font-style: italic;">might </span>be accounted for; might override the importance of re-arranging it.</li></ul><span style="font-weight: bold;">I/O Request to Hardware Operations:</span><br>Following example illustrates the process:<br><ul><li>Process issues a <span style="font-style: italic;">read</span> command</li><ul><li>Assume resource <span style="font-style: italic;">file </span>already open</li></ul><li>Command <span style="font-style: italic;">invokes </span>a system call</li><ul><li>Returns data from <span style="font-style: italic;">cache</span> or <span style="font-style: italic;">buffer</span> if its been alredy read</li><li>Otherwise, <span style="font-style: italic;">block </span>the process, schedule I/O operation, <span style="font-style: italic;">sub-system</span> command the <span style="font-style: italic;">device driver</span></li></ul><li>Device-driver uses <span style="font-style: italic;">buffer </span>to store incoming data; performs &nbsp;device singalling (<span style="font-style: italic;">i.e. </span>writing into device registers)</li><li>Controller <span style="font-style: italic;">operates</span> device as commanded by driver</li><li>Controller will <span style="font-style: italic;">interrupt </span>driver or<span style="font-style: italic;"> </span>permit<span style="font-style: italic;"> polling </span>till request is finished.</li><li><span style="font-style: italic;">Interrupt Handler </span>stores the incoming data, notifies <span style="font-style: italic;">device-driver,&nbsp;</span>which notifies Kernel</li><li>Kernel transfers data to <span style="font-style: italic;">address space </span>of process, process gets un-blocked.</li><li>Scheduler chooses process, execution resumes.</li></ul></body></html>