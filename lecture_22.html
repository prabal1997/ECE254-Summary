<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lecture_22</title></head>
<body><h2><span style="font-weight: bold;">Caching</span> </h2><ul><li>Optimizing access times to data stored in memory (<span style="font-style: italic;">physcial</span>, <span style="font-style: italic;">hard-disk</span>, or <span style="font-style: italic;">other</span> caches).</li><li>Only useful in certain instances i.e. when Temporal and Spatial Locality is exhibited.</li><ul><li><span style="font-weight: bold;">Temporal Locality:</span> Recently accessed memory is likely to be accesed again.</li></ul><ul><li><span style="font-weight: bold;">Spatial Locality:</span> Addresses around recently accessed memory likely to be accessed.</li></ul></ul><h2><span style="font-weight: bold;">Types of Caching Algorithms</span></h2><ul><li><span style="font-weight: bold;">Local Algorithms:</span> Each process has a fixed-number of pages in cache.</li><li><span style="font-weight: bold;">Global Algorithms:</span> Each process has a different-number of pages in cache dynamically calculated based on need.</li><ul><li><span style="font-style: italic;">'need'</span> is based on <span style="font-weight: bold;">PFF</span> (Page Fault Frequency), which needs to be close to a defined value for performance reasons.</li><ul><li><span style="font-style: italic;">NOT</span> true for <span style="font-weight: bold;">FIFO cache-management</span> algorithm.</li></ul></ul></ul><h2><span style="font-weight: bold;">Caching Algorithms</span></h2>&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">NOTE: </span>If a cache entry was <span style="font-style: italic;">modified </span>before being evicted, it <span style="font-style: italic;">needs </span>to be written back to the main memory.<ul><li><span style="font-weight: bold;">Not Recently Used:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li><span style="font-weight: bold;"></span>Cache lines/entries have&nbsp;<span style="font-style: italic;">R </span>(read) and&nbsp;<span style="font-style: italic;">M </span>(Modified) bits.</li><li><span style="font-style: italic;">R </span>bit periodically cleared; <span style="font-style: italic;">M </span>bit cleared after main-memory value updated.</li></ul><li><span style="font-weight: bold;">Cache hit: </span><span style="font-style: italic;">R </span>or<span style="font-style: italic;"> M </span>bits are modified appropriately</li><li><span style="font-weight: bold;">Cache Miss:&nbsp;</span></li><ul><li>Cache entries are sorted into <span style="font-style: italic;">'buckets'</span> based on R, M bit values.</li><li><span style="font-style: italic;"></span><span style="font-weight: bold;">R, M</span> = 0, 0 &lt; 0, 1 &lt; 1, 0, &lt; 1, 1 is the order of importance for cache entries to be evicted.</li></ul></ul><li><span style="font-weight: bold;">FIFO:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li><span style="font-weight: bold;"></span>Cache lines/entries<span style="font-weight: bold;">&nbsp;</span>are elements of an array-implemented <span style="font-weight: bold;">FIFO queue.</span></li><li>A <span style="font-style: italic;">pointer</span> points to some cache-entry (the oldest one) at any given moment.</li></ul><li><span style="font-weight: bold;">Cache hit: </span>Nothing happens.</li><li><span style="font-weight: bold;">Cache miss: </span>Currently pointed-to entry is evicted to be replaced; Pointer is <span style="font-weight: bold;">incremented </span>(<span style="font-style: italic;">Pointer</span><span style="font-weight: bold;"> </span>will wrap around the array if required)<br></li></ul></ul><span style="font-weight: bold;"></span><ul><li><span style="font-weight: bold;">Second Chance:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li><span style="font-weight: bold;"></span>Like <span style="font-weight: bold;">FIFO </span>technique.</li><li>Each entry has a <span style="font-style: italic;">R </span>bit.</li><li>A <span style="font-style: italic;">pointer</span> points to some cache-entry (the oldest one) at any given moment.</li></ul><li><span style="font-weight: bold;">Cache hit: </span>set the <span style="font-style: italic;">R </span>bit.<span style="font-weight: bold;"><span style="font-style: italic;"></span></span></li><li><span style="font-weight: bold;">Cache miss:</span></li><ul><li><span style="font-weight: bold;"></span>If <span style="font-style: italic;">R<span style="font-weight: bold;"> </span></span>= 0<span style="font-style: italic;"><span style="font-weight: bold;">, </span></span><span style="font-weight: bold;"></span>then we replace entry with new element, other-wise clear <span style="font-style: italic;">R</span>;</li><li>Pointer is incremented<span style="font-style: italic;"> </span>(<span style="font-style: italic;">Pointer</span><span style="font-weight: bold;"> </span>will wrap around the array if required.)<br></li></ul></ul></ul><ul><li><span style="font-weight: bold;">Least Rencently Used:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li><span style="font-weight: bold;"></span>Like <span style="font-weight: bold;">Circular Double Queue </span>technique.</li><li><span style="font-style: italic;">Head</span> points to the oldest element.</li></ul><li><span style="font-weight: bold;">Cache hit: </span>move the element to the end of the list.<span style="font-weight: bold;"><span style="font-style: italic;"></span></span></li><li><span style="font-weight: bold;">Cache miss:</span></li><ul><li>Delete&nbsp; <span style="font-style: italic;">Head&nbsp;</span>node.</li><li>Add new cache-entry to end of list.</li></ul></ul><li><span style="font-weight: bold;">Not Frequently Used:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li>Implemented using array.<span style="font-weight: bold;"><br></span></li></ul><ul><li>Each entry has a byte-sized <span style="font-style: italic;">counter.</span><span style="font-weight: bold;"></span></li></ul><li><span style="font-weight: bold;">Cache hit:</span></li><ul><li><span style="font-style: italic;">C</span><span style="font-style: italic;">ounter </span>is incremented.</li></ul><li><span style="font-weight: bold;">Cache miss:</span></li><ul><li>Delete&nbsp;the element with lowest <span style="font-style: italic;">counter</span>.</li><li>Add&nbsp;new entry with counter value set to '1'. </li></ul></ul><li><span style="font-weight: bold;">Not Frequently Used + Aging:</span></li><ul><li><span style="font-weight: bold;">Operation:</span></li><ul><li>Implemented using array.<span style="font-weight: bold;"><br></span></li></ul><ul><li>Each entry has a byte-sized <span style="font-style: italic;">counter.</span><span style="font-weight: bold;"></span></li></ul><li><span style="font-weight: bold;">Cache hit:</span></li><ul><li><span style="font-style: italic;">Every </span>entry's <span style="font-style: italic;">counter </span>is right-shifted.<span style="font-weight: bold;">&nbsp;</span></li></ul><ul><li><span style="font-weight: bold;"></span><span style="font-style: italic;">counter</span>&nbsp;of accessed entry has left-most bit changed to '1'.<span style="font-weight: bold;"><span style="font-style: italic;"></span></span></li></ul><li><span style="font-weight: bold;">Cache miss:</span></li><ul><li>Delete&nbsp; lowest-value element.<span style="font-weight: bold;"></span></li><li>Right-shift <span style="font-style: italic;">all</span> counters</li><li>Set the left-most bit to '1'</li></ul></ul></ul><br><span style="font-weight: bold;">Best Algorithm: LRU </span>(with Hardware Support)<span style="font-weight: bold;">, </span>or<span style="font-weight: bold;"> NFU + Aging</span></body></html>